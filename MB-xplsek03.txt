#### Stručně ale věcně odpovězte na následující otázky: ######

1. Jaká byla dosažena výkonnost v Intel Advisoru pro implementace ref, line a batch
(v GFLOPS)? (0.5b)
==============================================================================
ref - 2.99 GFLOPS
line - 14.86 GFLOPS
batch - 23 GFLOPS


2. Porovnejte implementaci referenčního rešení oproti "Line" a "Batch" implementaci. 
Jakým způsobem jsou načítána data, proč, a jaký to má vliv na výkon. (1b)
==============================================================================
U ref nedochází k vektorizaci vnitřní smyčky kvůli závislostem zImag a zReal, funkce pro výpočet každého bodu se spouští v cyklu. U ostatních řešení byly dle logu compileru smyčky vždy vektorizovány, zarovnána data a vektorizovány i inicializační smyčky pro nahrání výchozích hodnot.

V implementaci Batch s přehozením smyček je využitá vektorizace na vnitřní smyčce, s využitím simd redukce aby nedocházelo k opakování výpočtů, změněny některé datové typy, je zvýšena úroveň chybovosti na 0.1, u size=1000 masivní zrychlení. Načítá data zarovnaná na velikost cache a na nich paralelně provádí výpočet hodnoty bodu v cyklech po bloku, má tedy lepší prostorovou a časovou lokalitu. Jsou odstraněny podmínky z vektorizované smyčky, místo nich je použit (1-b)*V + (b)*V výpočet.

V implementaci Line bez přehození smyček dochází k paralelnímu zpracování řádku vektorizací smyčky; vektorizovaný for cyklus není na nejnižší úrovni ale na druhé nejnižší, tedy obsahuje o jeden cyklus méně a výpočet hodnoty bodu je jednodušší - žádné podmínky navíc a načítání z pomocných proměnných. Vliv na výkon: běží velmi rychle, přestože přístup do paměti není optimální (poor spatial locality dle logu).


3. Porovnejte Roofline všech modelů. Jsou implementace memory 
bound? Jaká je vaše aritmetická intenzita? Dokázali byste ji přibližně spočítat 
i ručně a jak? (1b)
==============================================================================
Aritmetická intenzita se dá vypočítat jako počet floating point operací / 1B. Jde spočítat ručně jako podíl časové složitosti programu / jeho prostorová složitost, tj: 
(počet FLOPS)/(B paměti někam umístěné/přemístěné programem).

ref - aritmetická intenzita: 13.8. Pod hranicí propustnosti DRAM, je CPU i memory bound. Vzhledem k ostatním implementacím je o dost níž pod úrovní DRAM. Odpovídá závislostem ve výpočtu hodnoty pixelu.

line - aritmetická intenzita: 7.12. Hlavní vektorizovaná smyčka stále pod hranicí propustnosti DRAM, paměťová propustnost výše než ref, CPU i memory bound, je způsobeno neefektivním přístupem do paměti (vektorizuje po řádku, dochází tedy k výpadkům cache), proto je memory bound. Pod CPU hranicí scalar add peak, tzn je potřeba optimalizovat vektorizaci, zejm. odstranění podmíky z cyklu.

batch - aritmetická intenzita: 0.476, výrazně nižší. Efektivnější přístup do paměti než u obou předchozích, hlavní vektorizovaná smyčka je pod úrovní L2, o dost výše než u line a ref, ale je potřeba v Advisoru zkontrolovat přístupy do cache a zarovnání. Pomocná vektorizovaná smyčka na úrovni propustnosti L3, není nijak podstatné, protože strávený čas = 20ms. Úroveň CPU bound = na hranici DP vector peak, vektorizace tedy probíhá.


4. Komentujte vliv velikosti cache na výkonnost a chování na větších 
velikostech domény. (1b)
==============================================================================
Větší cache sníží počet nutných přístupů do paměti, zlepší se časová i prostorová lokalita a tím se o něco sníží čas potřebný ke zpracování většího datasetu.


5. Jaký vliv na výkonnost má symetrie? Lze tento rozdíl pozorovat v Intel Advisor? 
(nápověda: instrukce) (0.5b)
============================================================================== 

Symetrie dat umožnuje vynechat celou jednu polovinu výpočtu, tj počet iterací cyklů nutných k dokončení úlohy bude poloviční + instrukce které jsou potřeba k duplikaci horní poloviny dat do spodní. Rozdíl bude vidět např. v sekci Assembly v Advisoru.